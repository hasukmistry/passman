"use strict";
var http = require('http')
    , fs = require('fs')
    , crypto = require('crypto')
    , moment = require('moment')
    , Sequence = require('futures').sequence
    , Promise = require('future')
    , exec = require("child_process").exec;

const CryptoJS = require("crypto-js")

const isDevelopment = process.env.NODE_ENV !== 'production'

class encrypt {
    // Stores name of outguess library.
    _outguess = '';

    // platform need to be passed
    constructor(platform) {
        // lets support 3 platforms only
        // binary will be provided by app for mac and windows
        // Assumption - other os will have outguess installed
        if (platform === 'WINDOWS') {
            this._outguess = isDevelopment ? './resources/bin/windows/outguess.exe' : process.resourcesPath + '/bin/windows/outguess.exe'
        } else if(platform === 'MAC') {
            this._outguess = isDevelopment ? './resources/bin/mac/outguess' : process.resourcesPath + '/bin/mac/outguess'
        } else {
            // Assumption - outguess is installend
            this._outguess = 'outguess'
        }
    }

    get outguess() {
        return this._outguess;
    }

    encryption(data, image) {
        let outputFile = ''

        // this variable is generated by ./passman.js
        const filename = 'public.keyfile'
        const public_key_file = `${process.env.PASSMAN_USER_DIR}${filename}`

        // lets read file generated while sign up
        // this will extract 32 character key
        let pub_key

        var promise = Promise()

        fs.access(public_key_file, fs.constants.F_OK, (err) => {
            if ( err ) {
                // file not exists.
                promise.fulfill(true, 'Security key does not exists.')

                next()
            } else {
                // file exists, lets read.
                let contents = fs.readFileSync(public_key_file)

                contents = Buffer.from(contents, 'base64').toString()

                // 256-bit Key - 32 length string
                // extracted from pubkey file
                const ENCRYPTION_KEY = CryptoJS.TripleDES.decrypt(contents, process.env.PASSMAN_PUBLIC_SECURITY_KEY).toString(CryptoJS.enc.Utf8)

                let user_email = process.env.PASSMAN_APP_USER_EMAIL

                // lets read user password
                // password and key will be used for cipher encryption
                const db = require('./db')

                try {
                    let main = this
                    // lets get user password
                    db.serialize(function() {
                        db.each(`SELECT * from user where email="${user_email}";`, function(err, row) {
                            const password = CryptoJS.Rabbit.decrypt(row.password, process.env.PASSMAN_PASSWORD_KEY).toString(CryptoJS.enc.Utf8)

                            Sequence()
                                .then(function(next) {
                                    main.perform(ENCRYPTION_KEY, password, data, image)
                                        .when(function(err, data) {
                                            // console.log('[OUTPUT] image path: ' + data)

                                            // processed file
                                            outputFile = data

                                            promise.fulfill(undefined, data)

                                            next()
                                        })
                                })
                        })
                    })
                } catch ( error ) {
                    // error
                    promise.fulfill(true, error.toString())

                    next()
                }
            }
        })

        return promise
    }

    perform(ENCRYPTION_KEY, PASSWORD, DATA, IMGFILE) {
        let main = this
        ENCRYPTION_KEY = Buffer.from(ENCRYPTION_KEY)

        const algorightm = 'aes-256-ctr'
        // convert json to string
        const msg = JSON.stringify(DATA)

        // always in jpeg
        const outputImageName = DATA.title.trim().toLowerCase().replace(/\s/g, '-') + '-' + moment().valueOf().toString(36).toString('utf8') + '.jpg'

        var promise = Promise()

        new Sequence()

            .then(function(next) {
                const iv = crypto.randomBytes(16)

                const cipher = crypto.createCipheriv(algorightm, Buffer.from(ENCRYPTION_KEY, 'hex'), iv)

                // msg to write inside image
                let encrypted = cipher.update(msg)

                encrypted = Buffer.concat([encrypted, cipher.final()])

                var crypted = iv.toString('hex') + ':' + encrypted.toString('hex')

                next(crypted)
            })


            .then(function(next, crypted) {
                // writing temporary text file in user home directory
                var filename = process.env.PASSMAN_USER_DIR + moment().valueOf().toString(36).toString('utf8') + '.txt'
                fs.writeFile(filename, crypted, function(err, data) {
                    if (err) {
                        console.err('There was an error')
                    }
                    next(filename)
                });
            })


            .then(function(next, filename) {
                var outFilename = '';
                if ( typeof outputImageName !== 'undefined' ) {
                    outFilename = process.env.PASSMAN_USER_DIR + outputImageName
                } else {
                    outFilename = process.env.PASSMAN_USER_DIR + moment().valueOf().toString(36).toString('utf8') + '.jpg'
                }

                next(filename, outFilename)
            })

            .then(function(next, filename, outFilename) {
                var cmd = main._outguess + " -k \'" + PASSWORD + "\' -d  " + filename + " " + IMGFILE + " " + outFilename

                // console.log( cmd )
                exec(cmd , function(err, stdout, stderr) {
                    if ( err ) {
                        // console.log(err)
                        // if command fails lets not create anything
                        next(filename, '')
                    } else {
                        next(filename, outFilename)
                    }
                })
            })


            .then(function(next, filename, outFilename) {
                fs.unlink(filename, function() {
                    promise.fulfill(undefined, outFilename)
                    next()
                });
            });


            return promise;
    }
}

module.exports = encrypt